#summary Client specification for the Google Safe Browsing v2 protocol
#labels Featured,Phase-Implementation

Status: DRAFT as of 2007/07/20

Copyright 2007 Google Inc.  All Rights Reserved.

Authors: Garrett Casto, RaphaÃ«l Moll, and Marria Nazif

Notes: The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119. 

= 1. Background =

Google provides data for the anti-phishing feature implemented in Firefox 2 and Google Desktop. These clients get their blacklist and whitelist data using an "update protocol".  A new protocol, version 2, is designed to address some shortcomings of the previous protocol and is described in this specification.

_Note_: This document assumes the reader is familiar with the anti-phishing service. For an overview of the phishing protection in Firefox, see the [http://wiki.mozilla.org/Phishing_Protection:_Design_Documentation design doc on Mozilla.org]. However readers need not be familiar with the details of the version 1 of the protocol to understand the second version.

Version 1 of the update protocol is inefficient and not scalable. Caveats of the version 1 of the protocol include:

    * It does not support partial list updates unless a client has a recent version of the list already fully downloaded. A new client must download the entire list of phishing entries at once or else it will never get any data. As a result, some clients using slow connections take a very long time to download the full list, the request times out, and they never download anything.

    * It sends phishing data to the client in oldest to newest order, which is inefficient for phishing sites since they have a very short lifetime.
    * Expiring old entries requires listing them in updates, which actually consumes bandwidth.


= 2. Overview =

Version 2 of the update protocol is designed with the following characteristics:

    * Each list type has one canonical list divided into chunks, rather than incrementing list versions.  Each chunk is assigned a unique identifier and describes entries to be added or removed from the blacklist.
    * Clients can recommend a download size that they want to see, although their request is not guaranteed by the server.
    * Clients inherently perform _partial_ updates each time they connect, and the server will send the most valuable data to client first (for example, perhaps the most recent data).
    * The chunk structure is determined by the list type.  For example, in some cases chunk entries are plain text expressions and in some cases they are hash values.


As with the previous protocol, the new protocol supports many different blacklists or whitelists. List names are in the form "provider-type-format", e.g. "goog-phish-sha128".  Each item in a list will represent an expression that will match a malicious url, but the exact format depends on the list type and how the content is used is application-specific.  Note that the rest of the specification will generally talk about lists in terms of blacklists but the protocol itself is agnostic to the content of the list.  (See the *List Contents* section below for details.)

The lists are divided into chunks, the smallest unit of data that will be sent to the client. This allows for supporting partial updates to all users, including new users, and allows for more flexibility in choosing which data to send the client.  The actual chunk size is determined by the server.

There are two kind of chunks:

    * "_add_" chunks contain new entries for the list.
    * "_sub_" chunks contains entries that need to be removed from the client's list.


Chunks are assigned a number, which is a sequence number for chunks of the same type.
For example for a given list, there will be:

    * "_Add_" chunk #1, "_add_" chunk #2,..., "_add_" chunk #N.
    * "_Sub_" chunk #1, "_sub_" chunk #2,..., "_sub_" chunk #M.
    * The total number of "_add_" and "_sub_" chunks will generally be different.
    * There is no chunk number 0. Chunk numbers start with 1.
    * Chunk numbers within the same chunk type grow increasingly, without gaps.


For a blacklist, "_add_" chunks contain the new URLs regular expressions or hashes to add to the blacklist and "sub" chunks contains the false positives that need to be removed from the client's blacklist.

In contrast with the previous protocol, the server no longer lists all the URLs that need to be expired. To save bandwidth, the server indicates which chunks need to be deleted by specifying a previously-seen "_add_" chunk number.

= 3. Protocol Specification =

The client-server exchange uses a simple pull model: the client connects regularly to the server and pulls some updates. The data exchange can be summarized as follows:

    * The client sends an HTTP POST request to the server and specifies which lists it wants to download. It indicates which chunks it already has. It specifies the desired download size.
    * The server replies with an HTTP error code and an HTTP response. If there is any data, the response contains the chunks for the various requested lists.


Besides the data exchange, the server provides a way for the client to discover which lists are available.

== 3.1. R-BNF ==

This document uses a R-BNF notation, which is a mix between Extended BNF and PCRE-style regular expressions:

    * Rules are in the form: name = definition. Rule names referenced as-is in the definition. Angle brackets may be used to help facilitate discerning the use of rule names.
    * Literals are surrounded by quotation marks: "literal".
    * Sequences: (rule1 rule2) or simply rule1 rule2.
    * Alternatives groups: (rule1 | rule2).
    * Optional groups: {{{[}}}rule{{{]}}}.
    * Repetition: rule{{{*}}} means 0 or more of this rule or this group.
    * Repetition: rule+ means 1 or more of this rule or this group.


The following basic rules that describe the US-ASCII character set are also used as defined in RFC 2616:

    * OCTET = <any 8-bit sequence of data>
    * CHAR = <any US-ASCII character (octets 0 - 127)>
    * UPALPHA = <any US-ASCII uppercase letter "A".."Z">
    * LOALPHA = <any US-ASCII lowercase letter "a".."z">
    * ALPHA = UPALPHA | LOALPHA
    * DIGIT = <any US-ASCII digit "0".."9">
    * CTL = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
    * CR = <US-ASCII CR, carriage return (13)>
    * LF = <US-ASCII LF, line-feed (10)>
    * SP = <US-ASCII SP, space (32)>
    * TAB = <US-ASCII HT, horizontal-tab (9)>
    * <"> = <US-ASCII double-quote mark (34)>
    * LWS = Linear White Space <one or more of SP or TAB>
    * EOF = End of File / End of Stream

== 3.2. HTTP Request for List ==

This is used by clients to discover the available list types.

=== 3.2.1. Request's URL ===

The client performs a request by sending an HTTP POST request to the URI:
{{{
http://sb.google.com/safebrowsing/list?client=CLIENTID&appver=CLIENTVER&pver=PVER&wrkey=MACKEY
}}}

Required CGI parameters:

    * The *client* parameter indicates the type of client, e.g. "myapplication".
    * The *appver* parameter indicates the version of the client, e.g. "1.5.2".
    * The *pver* parameter indicates the protocol version that the client supports. Currently this must be "2.0". The format is "major.minor". If we update the protocol, we will make sure that minor revisions are always compatible; however major revision will be incompatible and the server MAY NOT be able to cope with an older protocol.


Optional CGI parameters:

    * The *wrkey* parameter is used by clients who want a MAC for the response. See the *MAC* section below for more details.


Formal R-BNF description:
{{{
CLIENTID  = (LOALPHA | "-")+
CLIENTVER = DIGIT ["." DIGIT]
PVER      = DIGIT "." DIGIT
MACKEY    = (ALPHA | DIGIT)+
}}}

Example:
{{{
http://sb.google.com/safebrowsing/list?client=myapplication&appver=1.5.2&pver=2.0
}}}

Client Behavior:

    * The client MUST specify the *client*, *appver* and *pver* CGI parameters.

=== 3.2.2. Request's Body ===

There is no body content for this request -- any body data will be ignored by the server.

== 3.3. HTTP Response for List ==

The server replies using the error code and response body of the HTTP response. No specific HTTP headers is set by the server -- some HTTP headers MAY be present but are not authoritative.

=== 3.3.1. Response Code ===

The server generates the following HTTP error codes:

    * 200: OK -- Data is available in the HTTP response body.
    * 400: Bad Request -- The HTTP request was not correctly formed. The client did not provide all required CGI parameters.
    * 401: Not Authorized -- The client id is invalid.
    * 503: Service Unavailable -- The server cannot handle the request. Clients MUST follow the backoff behavior specified in the *Update Frequency* section.
    * 505: HTTP Version Not Supported -- The server CANNOT handle the requested protocol major version.

=== 3.3.2. Response Body ===

There is no data in the response body for codes in 3xx, 4xx and 5xx.

The response body may be empty.  When present, the response body contains the name of each list that this client can access.
Formal R-BNF description of the response body:
{{{
BODY     = (LISTNAME LF)* EOF
LISTNAME = (LOALPHA | DIGIT)+ "-" LOALPHA+ "-" (LOALPHA | DIGIT)+
}}}

Example:
{{{
goog-phish-sha128
goog-malware-sha128
}}}

== 3.4. HTTP Request for Data ==

This is used by clients who want to get new data for known list types.

=== 3.4.1. Request's URL ===

The client performs a datarequest by sending an HTTP POST request to the URI:
{{{
http://sb.google.com/safebrowsing/download?client=CLIENTID&appver=CLIENTVER&pver=PVER&wrkey=MACKEY
}}}

CGI parameters are the same as those used in the HTTP Request for List (section 3.2 above.)

Formal R-BNF description:
{{{
CLIENTID  = (LOALPHA | "-")+
CLIENTVER = DIGIT ["." DIGIT]
PVER      = DIGIT "." DIGIT
MACKEY    = (ALPHA | DIGIT)+
}}}

Example:
{{{
http://sb.google.com/safebrowsing/download?client=myapplication&appver=1.5.2&pver=2.0
}}}

Client Behavior:

    * The client MUST specify the *client*, *appver* and pver cgi parameters.

=== 3.4.2. Request's body ===

The request body is used to specify what the client has and wants:

    * The client specifies the maxmum size of the download it wants to retrieve.
    * The client specifies which lists it wants to retrieve.
    * For each lists, the client specifies the chunk numbers it already has.


The format of the body is line oriented. Lines are separated by LF. Lines which cannot be understood are ignored by the server.

Formal R-BNF description of the request body:
{{{
BODY      = [SIZE LF] (LIST LF)+ EOF
SIZE      = "s;" DIGIT+                            # Optional size, in kilobytes and >= 1
LIST      = LISTNAME ";" [LISTINFO [":" LISTINFO]*]
LISTINFO  = (CHUNKTYPE ":" CHUNKLIST) | "mac"
LISTNAME = (LOALPHA | DIGIT)+ "-" LOALPHA+ "-" (LOALPHA | DIGIT)+
CHUNKTYPE = "a" | "s"                              # 'Add' or 'Sub' chunks
CHUNKLIST = (RANGE | NUMBER) ["," CHUNKLIST]
NUMBER    = DIGIT+                                 # Chunk number >= 1
RANGE     = NUMBER "-" NUMBER
}}}

Note that the last line of the body MUST have a trailing line-feed.

The size request is optional. If present, the number indicates the ideal maximum response size, in kilobytes, that the server should reply. The size is used a hint by the server; the actual reply size may vary and could be larger or smaller than the ideal size specified by the client.

We strongly recommend that clients omit the size field unless they have a special need to limit the response size. Clients who are operating on a small bandwidth, such as a modem, may want to use the size field to limit the response size. However doing so may cause the client to permanently lag behind. If unsure, clients should omit the size field and let the server decide of the appropriate response size.

Example 1:
{{{
goog-phish-sha128;a:1-3,5,8:s:4-5
acme-white-sha128;a:1-7:s:1-2
}}}
In this example, the client requests data for two lists. It then lists the chunks it already has for each list type.

Example 2:
{{{
s;200
goog-phish-sha128;a:1-3,5,8:s:4-5
acme-white-sha128;a:1-7:s:1-2
}}}

In this example, the client requests a response size of 200 kilobytes for the two given lists. It then lists the chunks it already has for each list type.

Note that at first the client has no data so it has no chunk number on its side. Generally speaking if a client does not have any chunks of one type it should not list the corresponding chunk type.
Example (inline comments start after a # and are not part of the protocol:)
{{{
goog-phish-sha128;a:1-5      # The client has 'add' chunks but no 'sub' chunks

acme-malware-sha128;           # The client has no data for this list.

acme-white-sha128;mac        # No data here either and it wants a mac
}}}

Examples of good chunk lists:
{{{
goog-phish-sha128;a:1-5,10,12:s:3-8
goog-phish-sha128;a:1,2,3,4,5,10,12,15,16
goog-phish-sha128;a:1-5,10,12,15-16
goog-phish-sha128;a:16-10,2-5,4
}}}

Examples of bad chunk lists:
{{{
goog-phish-sha128              # Missing ; at end of list name
goog-phish-sha128;5-1,16-10    # Missing 'a:' or 's:' for chunk type
goog-phish-sha128;a:5-1:s:     # Missing chunk numbers for 's:'
}}}

Server Behavior:

    * The server MUST reject a request with an empty body.
    * The server MUST ignore ill-formated lines and MUST reply to the correctly formatted ones.
    * The server SHALL try to accommodate the desired response size. The requested size takes into account only chunk data, not any metadata.
    * However if the desired size is less than at least one chunk, the server MUST send at least one chunk.


Client Behavior:

    * The client MUST request at least one list.
    * The last line of the body MUST have a trailing LF character.

== 3.5. HTTP Response for Data ==

The server replies using the error code and response body of the HTTP response. No specific HTTP headers is set by the server -- some HTTP headers MAY be present but are not authoritative.

=== 3.5.1. Response Code ===

The server generates the following HTTP error codes:

    * 200: OK -- Data is available in the HTTP response body.
    * 304: Not Modified -- The client is up-to-date.
    * 400: Bad Request -- The HTTP request was not correctly formed. The client did not provide all required CGI parameters or the body did not contain any meaningful entries.
    * 403: Forbidden -- The client id is invalid.
    * 503: Service Unavailable -- The server cannot handle the request. Clients MUST follow the backoff behavior specified in the *Update Frequency* section.
    * 505: HTTP Version Not Supported -- The server CANNOT handle the requested protocol major version.

=== 3.5.2. Response Body ===

The response body will not be present for codes in 4xx and 5xx.

When present, the response body contains the following information:

    * The next polling interval to use, i.e. the number of seconds before the client should contact the server again.
    * For each list, it's name followed by all chunk data.


The body contains both the chunk data (binary blobs) and the metadata describing the chunks. The metadata is line oriented.
Formal R-BNF description of the response body:
{{{
BODY      = NEXT LF [REKEY LF] (LIST LF)+ EOF
REKEY     = "k: pleaserekey"
NEXT      = "n:" DIGIT+                               # Minimum delay before polling again in seconds
LIST      = "i:" LISTNAME [MAC] (LF LISTDATA)+
MAC       = "," (LOALPHA | DIGIT)+
LISTNAME = (LOALPHA | DIGIT)+ "-" LOALPHA+ "-" (LOALPHA | DIGIT)+
LISTDATA  = ADD-HEAD | SUB-HEAD | ADDDEL-HEAD | SUBDEL-HEAD
ADD-HEAD  = "a:" CHUNKNUM ":" CHUNKLEN LF CHUNKDATA   # Length in bytes in decimal
SUB-HEAD  = "s:" CHUNKNUM ":" CHUNKLEN LF CHUNKDATA   # Length in bytes in decimal
CHUNKNUM  = 1*DIGIT                                   # Sequence number of the chunk
CHUNKLEN  = 1*DIGIT                                   # Size of the chunk data in bytes >= 1
CHUNKDATA = <CHUNKLEN number of unsigned bytes>
ADDDEL-HEAD  = "ad:" CHUNKLIST
SUBDEL-HEAD  = "sd:" CHUNKLIST
CHUNKLIST = (RANGE | NUMBER) ["," CHUNKLIST]
NUMBER    = DIGIT+                                    # Chunk number >= 1
RANGE     = NUMBER "-" NUMBER
}}}

Generally speaking lines are in the form "keyword colon parameters". The keyword is limited to one character in this implementation. We reserve the right to use longer keywords later.

The format for _add_ and _sub_ chunks is exactly the same. The number of bytes is followed by one line-feed character (LF, \n) then a binary blob of the indicated length. The length is expressed in bytes in decimal. The LF that follows CHUNKLEN is a separator and is not counted in the length itself. Chunk data encoding is explained in the next section. Chunk data is both encoded and compressed according to which list type it is (see *List Contents* section below). The length described by CHUNKLEN is the size after encoding and/or compression.

The _adddel_ and _subdel_ chunks are used to expire previous _add_ and _sub_ chunks. Consequently they have no associated chunk data. More than one chunk can be specified, either by listing each number or using a range or a combination of both.  When an _add_ chunk is deleted, the client can delete the data associated with that chunk.  When a _sub_ chunk is deleted, the client simply no longer reports that it received that sub chunk in the past.

If there are no chunks of a given type, the entire LISTDATA will be omitted. That is for example if there are no _sub_ or _subdel_ chunks for a given list, there will be no corresponding "s:" or "sd:" information in the metadata.

Chunk types (_add_, _sub_, _adddel_ and _subdel_) can be presented in any order. They can even be intermixed. The order of the chunks depends on the implementation of the server and the clients MUST NOT rely on any empirical behavior. Moreover, the sequence order in which chunks of the same type are present in the stream is not guaranteed.

Example:
{{{
n:1200
i:goog-phish-sha128
a:4:1200
[encoded data]
s:3:100
[encoded data]
a:6:800
[encoded data]
a:7:1200
[encoded data]
s:4:42
[encoded data]
sd:1,2
i:acme-white-exp
a:9:324
[encoded data]
a:10:325
[encoded data]
ad:1-2,4-5,7
sd:2-6
}}}

In this example, there are no _adddel_ chunks for the "goog-phish-sha128" list, and there are no _sub_ chunks for the "acme-white-exp" list.

Server Behavior:

    * The server CAN change the "_next_" value (i.e. "n:" line) for each response.


Client Behavior:

    * The client MUST respect the "_next_" value and not contact the server again until the specified delay has expired. See the *Update Frequency* section below for more information on how often the server can be contacted after replying with an HTTP error code.
    * The client MUST ignore a line starting with a keyword that it doesn't understand.

    * The client MUST refuse to use the whole response if any of the _add_, _sub_, _adddel_ and _subdel_ metadata headers or the binary data cannot be parsed successfully.
    * Upon successful decoding of all the response and all the binary data, the client MUST update its lists in an atomic fashion.

== 3.6. List Contents ==

The contents of each chunk depends on the list type that the chunk belongs to. Currently, the possible lists are:

    * *goog-phish-sha128*: a list of hashed suffix/prefix expressions representing sites that should be blocked because they are hosting phishing pages.
    * *goog-malware-sha128*: a list of suffix/prefix regular expressions representing sites that should be blocked because they are hosting malware pages.
    * *goog-white-exp*: a list of suffix/prefix regular expressions representing sites that are known to be trusted. Note that this list should only be used for "enhanced mode" clients that do direct lookups to Google to determine which sites are phishy. In that case, if a site is on the whitelist there is no need to send the query to Google.


Both the "exp" and "sha128" list types rely on suffix/prefix expressions. Each of the suffix/prefix expressions consists of a host suffix (or full host) and a path prefix (or full path).  Note that the path prefix consists of full path components.  If the expression contains the full path, there may optionally be query parameters appended to the path.

Examples:
{{{
Regular expression:                  http\:\/\/.*\.a\.b\/mypath\/.*
Suffix/prefix expression:            a.b/mypath/
Regular expression:            http\:\/\/.*.c\.d\/full\/path\.html?myparam=a
Suffix/prefix regular expression:  c.d/full/path.html?myparam=a
}}}

For the "exp" list format, the chunk is compressed using zlib. After decompression, the chunk contains one plaintext suffix/prefix expression per line. 


For the "sha128" list format, the chunk is not compressed. Each entry in the chunk is composed of the 128 most significant bits of the SHA 256 hash of a suffix/prefix expression.


Here are some example of "sha128" hashes, based on the examples from
[http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf FIPS-180-2]:

  * Example B1:
    * Input is `"abc"`
    * SHA 256 digest is `ba7816bf 8f01cfea 414140de 5dae2223 b00361a3 96177a9c b410ff61 f20015ad`.
    * Our key is `ba7816bf 8f01cfea 414140de 5dae2223`.
  * Example B2:
    * Input is `"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"`
    * SHA 256 digest is `248d6a61 d20638b8 e5c02693 0c3e6039 a33ce459 64ff2167 f6ecedd4 19db06c1`.
    * Our key is `248d6a61 d20638b8 e5c02693 0c3e6039`.


Here's a unit test you can use to validate the key computation (in pseudo-C):
{{{
  // Example B1 from FIPS-180-2
  string input1 = "abc";
  string output1 = TruncatedSha256(input1);
  int expected1[] = { 0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
                      0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23 };
  assert(output1.size() == 16);  // We always use 16 bytes (128 bits)
  for (int i = 0; i < output1.size(); i++) assert(output1[i] == expected1[i]);

  // Example B2 from FIPS-180-2
  string input2 = "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq";
  string output2 = TruncatedSha256(input2);
  int expected2[] = { 0x24, 0x8d, 0x6a, 0x61, 0xd2, 0x06, 0x38, 0xb8,
                      0xe5, 0xc0, 0x26, 0x93, 0x0c, 0x3e, 0x60, 0x39 };
  assert(output2.size() == 16);
  for (int i = 0; i < output2.size(); i++) assert(output2[i] == expected2[i]);

  // Example B3 from FIPS-180-2
  string input3(1000000, 'a');  // 'a' repeated a million times
  string output3 = TruncatedSha256(input3);
  int expected3[] = { 0xcd, 0xc7, 0x6e, 0x5c, 0x99, 0x14, 0xfb, 0x92,
                      0x81, 0xa1, 0xc7, 0xe2, 0x84, 0xd7, 0x3e, 0x67 };
  assert(output3.size() == 16);
  for (int i = 0; i < output3.size(); i++) assert(output3[i] == expected3[i]);
}}}



= 4. MAC =

We support a Message Authentication Code in this protocol, similar to the old protocol.

== 4.1. HTTP Request for Key ==

In order to receive a MAC, the client must request a key from the server over a secure connection.  The getkey request should only be called once per client, unless the server requests that the client changes its key (see below).

=== 4.1.1. Request's URL ===

The client performs a request by sending an HTTP GET request to the URI:
{{{
http://sb.google.com/safebrowsing/getkey?client=CLIENTID&appver=CLIENTVER&pver=PVER
}}}

CGI parameters are the same as those used in the HTTP Request for List (section 3.2 above.)

Example:
{{{
    http://sb.google.com/safebrowsing/getkey?client=myapplication&appver=1.5.2&pver=2.0
}}}

== 4.2. HTTP Response for Key ==

=== 4.2.1. Response Code ===

The server generates the following HTTP error codes:

    * 200: OK -- Data is available in the HTTP response body.
    * 400: Bad Request -- The HTTP request was not correctly formed. The client did not provide all required CGI parameters.
    * 401: Not Authorized -- The client id is invalid.
    * 503: Service Unavailable -- The server cannot handle the request. Clients MUST follow the backoff behavior specified in the *Update Frequency* section.
    * 505: HTTP Version Not Supported -- The server CANNOT handle the requested protocol major version.

=== 4.2.2. Response Body ===

There is no data in the response body for codes in 3xx, 4xx and 5xx.

When present, the response body contains a client key and a wrapped key.

Formal R-BNF description of the response body:
{{{
BODY   = "clientkey:" LENGTH ":" MACKEY LF "wrappedkey:" LENGTH ":" MACKEY EOF
LENGTH = DIGIT+
}}}

Example:
{{{
clientkey:24:pOAblTUiZFkLSv3xRiXKKQ==
wrappedkey:24:MTqdJvrixHRGAyfebvaQWYda
}}}

== 4.3. Requesting the MAC ==

The client must include the wrapped key in the request if it wants a MAC. For example, the request will look like this:
{{{
http://sb.google.com/safebrowsing/download?client=foo&appver=1.5&pver=2.0&wrkey=123
}}}

The client specifies whether it wants a MAC on a per list basis in the body of the POST data for the request by adding a keyword after each desired list:
{{{
s;200
goog-phish-sha128;a:1-3,5,8:s:4-5
acme-white-exp;a:1-7:s:1-2:mac
}}}

In the response, the MAC will be listed after the corresponding list name. For example:
{{{
n:1200
i:goog-phish-sha128
a:4:1200
[encoded data]
s:3:42
[encoded data]
i:acme-white-exp,my_mac_here
a:9:320
[encoded data]
d:1-2
}}}

The MAC is computed from an MD5 Digest over the following information: clientkey|separator|table data|separator|clientkey. The separator is the string :coolgoog: - that is a colon followed by "coolgoog" followed by a colon. The resulting 128-bit MD5 digest is websafe baset64 encoded.

== 4.4. Key Expiration ==

At any time, when a client includes the *wrkey* CGI parameter in a request, the server may prepend "e:pleaserekey" to any response, on a separate line.  This indicates that the client key is no longer valid and that the client should request a new key using the getkey request specified above.

= 5. Update Frequency =

 Providing the data on the server for updates and lookups requires a fair amount of resources. To help maintain a high quality of service, it may be necessary for the download servers to ask the client to make more or less frequent requests. To handle this, two mechanisms are available:

    * In its response, the server gives an _update_ _interval_, i.e. the delay in seconds before the next connection attempt should occur.
    * The client watches for HTTP timeouts or errors (i.e. HTTP response code 5xx) from the server and if too many errors occur, it increases in the time between requests.


Client Behavior:

    * The first update request MUST happen at a random interval between 0 and 5 minutes after the browser starts.
    * The second update request MUST happen at the update interval last specified by the server. If this value is unknown, the request MUST happen between 15 and 45 minutes later.
    * After that, each update MUST happen at the update interval last specified by the server.
    * If the client receives an error during update, it MUST try again in at least one minute.
    * If it receives three errors in a row, it MUST skip updates until at least 60 minutes have passed before trying again.
    * If it then receives another (4th) error, it MUST skip updates for the next 180 minutes and if it receives another (5th) error, it MUST skip updates for the next 360 minutes. It SHOULD continue to check once every 360 minutes until the server responds with a success message.
    * Once the client receives successful HTTP replies, the error stats are reset.

= 6. Performing Lookups =

== 6.1. Canonicalization ==
Before lookup in any list, the url must be canonicalized.

We assume that the client has parsed the URL and made it valid according to RFC 2396.  If it's an international url, use the ascii punycode representation.  The URL must include a path component, e.g. 'http://google.com/' must have a trailing slash.

To start, repeatedly URL-unescape the URL until it has no more hex-encodings.

To canonicalize the hostname:

Extract the hostname from the URL and then follow these steps:

    * Remove all leading and trailing dots
    * Replace consecutive dots with a single dot.
    * If the hostname can be parsed as an IP address, it should be normalized to 4 dot-separated decimal values.  The client should handle any legal IP address encoding, including octal, hex, and fewer than 4 components.
    * Lowercase the whole string. 


To canonicalize the path:

    * The sequences "/../" and "/./" in the path should be resolved, by replacing "/./" with "/", and removing "/../" along with the preceding path component.
    * Runs of consecutive slashes should be replaced with a single slash character.


After performing these steps, percent-escape all characters in the URL which are <= ASCII 32, >= 127, or "%". The escapes should use uppercase hex characters.

== 6.2. Simplified Regular Expression Lookup ==

Currently all valid list types rely on suffix/prefix expressions, as described in the List Contents section above. To perform a lookup for a given url, the client will try to form different possible host suffix and path prefix combinations and seeing if they match each list. Depending on the list type, the suffix/prefix combination may be hashed before lookup. For these lookups, only the host and path components of the URL are used. The scheme, username, password, and port are disregarded. If query parameters are present in the url, the client will also include a lookup with the full path and query parameters.

For the hostname, the client will try at most 5 different strings. They are:

    * the exact hostname in the url
    * up to 4 hostnames formed by starting with the last 5 components and successively removing the leading component.  The top-level domain can be skipped.


For the path, the client will also try at most 6 different strings. They are:

    * the exact path of the url, including query parameters
    * the exact path of the url, without query parameters
    * the 4 paths formed by starting at the root (/) and successively appending path components, including a trailing slash.


The following examples should help illustrate the lookup behavior:

For the url http://a.b.c/1/2.html?param=1, the client will try these possible strings:
{{{
a.b.c/1/2.html?param=1
a.b.c/1/2.html
a.b.c/
a.b.c/1/
b.c/1/2.html?param=1
b.c/1/2.html
b.c/
b.c/1/
}}}

For the url http://a.b.c.d.e.f.g/1.html, the client will try these possible strings:
{{{
a.b.c.d.e.f.g/1.html
a.b.c.d.e.f.g/
(Note: skip b.c.d.e.f.g, since we'll take only the last 5 hostname components, and the full hostname)
c.d.e.f.g/1.html
c.d.e.f.g/
d.e.f.g/1.html
d.e.f.g/
e.f.g/1.html
e.f.g/
f.g/1.html
f.g/
}}}

= 7. References =
    * [http://www.ietf.org/rfc/rfc2119.txt RFC 2119] -- Keywords for use in RFCs.
    * [http://www.ietf.org/rfc/rfc2616.txt RFC 2616] -- Hypertext transfer Protocol HTTP/1.1.
    * [http://wiki.mozilla.org/Phishing_Protection Mozilla/Firefox Phishing Protection].
    * [http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf FIPS-180-2] -- SHA 256

